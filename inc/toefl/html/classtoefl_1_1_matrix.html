<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>TOEFL: toefl::Matrix&lt; T, P &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="tablist"> 
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../../inc/dg/html/modules.html">dG</a></li>
    <li><a href="../../../inc/file/html/index.html">file</a></li>
    <li><a href="../../../inc/toefl/html/index.html">spectral</a></li>
    <li><a href="../../../inc/geometries/html/modules.html">geometry</a></li>
    <!--li><a href="../../../src/feltor/html/index.html">FELTOR code</a></li>
    <li><a href="../../../src/feltor2D/html/index.html">FELTOR2D code</a></li>
    <li><a href="../../../src/innto/html/index.html">INNTO code</a></li-->
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TOEFL
   </div>
   <div id="projectbrief">Tokamak edge fluid; library for building spectral code</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classtoefl_1_1_matrix.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classtoefl_1_1_matrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">toefl::Matrix&lt; T, P &gt; Class Template Reference<div class="ingroups"><a class="el" href="group___t_o_e_f_l.html">The TOEFL library</a> &raquo; <a class="el" href="group__containers.html">Containers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classtoefl_1_1_matrix.html" title="Matrix class of constant size that provides fftw compatible dynamically allocated 2D fields...">Matrix</a> class of constant size that provides fftw compatible dynamically allocated 2D fields.  
 <a href="classtoefl_1_1_matrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="matrix_8h_source.html">matrix.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for toefl::Matrix&lt; T, P &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classtoefl_1_1_matrix.png" usemap="#toefl::Matrix_3C_20T_2C_20P_20_3E_map" alt=""/>
  <map id="toefl::Matrix_3C_20T_2C_20P_20_3E_map" name="toefl::Matrix&lt; T, P &gt;_map">
<area href="classtoefl_1_1_ghost_matrix.html" title="Mimic a Matrix with ghostcells. " alt="toefl::GhostMatrix&lt; T, P &gt;" shape="rect" coords="0,56,157,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af8f935080301ca145915c3e2330134fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtoefl_1_1_matrix.html#af8f935080301ca145915c3e2330134fe">Matrix</a> (const size_t <a class="el" href="classtoefl_1_1_matrix.html#aa52708d41add23f7cc585e8c2ba0485e">rows</a>, const size_t <a class="el" href="classtoefl_1_1_matrix.html#acaaf1b7e09ef4b7524d6b36829f6e699">cols</a>, const bool <a class="el" href="classtoefl_1_1_matrix.html#a171550ab096ef57acfbd755c7bfe930f">allocate</a>=true)</td></tr>
<tr class="memdesc:af8f935080301ca145915c3e2330134fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty matrix.  <a href="#af8f935080301ca145915c3e2330134fe">More...</a><br /></td></tr>
<tr class="separator:af8f935080301ca145915c3e2330134fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fedb25468e7877b0c55d59ce9c1e35"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtoefl_1_1_matrix.html#a66fedb25468e7877b0c55d59ce9c1e35">Matrix</a> (const size_t <a class="el" href="classtoefl_1_1_matrix.html#aa52708d41add23f7cc585e8c2ba0485e">rows</a>, const size_t <a class="el" href="classtoefl_1_1_matrix.html#acaaf1b7e09ef4b7524d6b36829f6e699">cols</a>, const T &amp;value)</td></tr>
<tr class="memdesc:a66fedb25468e7877b0c55d59ce9c1e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and assign memory on the heap.  <a href="#a66fedb25468e7877b0c55d59ce9c1e35">More...</a><br /></td></tr>
<tr class="separator:a66fedb25468e7877b0c55d59ce9c1e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0bbffe530ad595079c99355458c064c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0bbffe530ad595079c99355458c064c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtoefl_1_1_matrix.html#ae0bbffe530ad595079c99355458c064c">~Matrix</a> ()</td></tr>
<tr class="memdesc:ae0bbffe530ad595079c99355458c064c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all allocated memory. <br /></td></tr>
<tr class="separator:ae0bbffe530ad595079c99355458c064c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed10cba858c6e424122ced79fab91087"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtoefl_1_1_matrix.html#aed10cba858c6e424122ced79fab91087">Matrix</a> (const <a class="el" href="classtoefl_1_1_matrix.html">Matrix</a> &amp;src)</td></tr>
<tr class="memdesc:aed10cba858c6e424122ced79fab91087"><td class="mdescLeft">&#160;</td><td class="mdescRight">deep copy of an existing <a class="el" href="classtoefl_1_1_matrix.html" title="Matrix class of constant size that provides fftw compatible dynamically allocated 2D fields...">Matrix</a>  <a href="#aed10cba858c6e424122ced79fab91087">More...</a><br /></td></tr>
<tr class="separator:aed10cba858c6e424122ced79fab91087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49de9ed627cd38701282b03ea52e3f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtoefl_1_1_matrix.html#aa49de9ed627cd38701282b03ea52e3f9">Matrix</a> (<a class="el" href="classtoefl_1_1_matrix.html">Matrix</a> &amp;&amp;temporary_src)</td></tr>
<tr class="memdesc:aa49de9ed627cd38701282b03ea52e3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Experimental move constructor in the new standard.  <a href="#aa49de9ed627cd38701282b03ea52e3f9">More...</a><br /></td></tr>
<tr class="separator:aa49de9ed627cd38701282b03ea52e3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa748bce65eba4b471e48e02e2e92072c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtoefl_1_1_matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtoefl_1_1_matrix.html#aa748bce65eba4b471e48e02e2e92072c">operator=</a> (const <a class="el" href="classtoefl_1_1_matrix.html">Matrix</a> &amp;src)</td></tr>
<tr class="memdesc:aa748bce65eba4b471e48e02e2e92072c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep assignment.  <a href="#aa748bce65eba4b471e48e02e2e92072c">More...</a><br /></td></tr>
<tr class="separator:aa748bce65eba4b471e48e02e2e92072c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c008428626e77f0d82eacab047cfe0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtoefl_1_1_matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtoefl_1_1_matrix.html#ad0c008428626e77f0d82eacab047cfe0">operator=</a> (<a class="el" href="classtoefl_1_1_matrix.html">Matrix</a> &amp;&amp;temporary_src)</td></tr>
<tr class="memdesc:ad0c008428626e77f0d82eacab047cfe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep move assignment.  <a href="#ad0c008428626e77f0d82eacab047cfe0">More...</a><br /></td></tr>
<tr class="separator:ad0c008428626e77f0d82eacab047cfe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171550ab096ef57acfbd755c7bfe930f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtoefl_1_1_matrix.html#a171550ab096ef57acfbd755c7bfe930f">allocate</a> ()</td></tr>
<tr class="memdesc:a171550ab096ef57acfbd755c7bfe930f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for void matrices.  <a href="#a171550ab096ef57acfbd755c7bfe930f">More...</a><br /></td></tr>
<tr class="separator:a171550ab096ef57acfbd755c7bfe930f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52708d41add23f7cc585e8c2ba0485e"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtoefl_1_1_matrix.html#aa52708d41add23f7cc585e8c2ba0485e">rows</a> () const </td></tr>
<tr class="memdesc:aa52708d41add23f7cc585e8c2ba0485e"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of rows  <a href="#aa52708d41add23f7cc585e8c2ba0485e">More...</a><br /></td></tr>
<tr class="separator:aa52708d41add23f7cc585e8c2ba0485e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaaf1b7e09ef4b7524d6b36829f6e699"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtoefl_1_1_matrix.html#acaaf1b7e09ef4b7524d6b36829f6e699">cols</a> () const </td></tr>
<tr class="memdesc:acaaf1b7e09ef4b7524d6b36829f6e699"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of columns  <a href="#acaaf1b7e09ef4b7524d6b36829f6e699">More...</a><br /></td></tr>
<tr class="separator:acaaf1b7e09ef4b7524d6b36829f6e699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2bcfc1183ab0d558f54c46531fb1a3"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtoefl_1_1_matrix.html#a1a2bcfc1183ab0d558f54c46531fb1a3">getPtr</a> ()</td></tr>
<tr class="memdesc:a1a2bcfc1183ab0d558f54c46531fb1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the address of the first element  <a href="#a1a2bcfc1183ab0d558f54c46531fb1a3">More...</a><br /></td></tr>
<tr class="separator:a1a2bcfc1183ab0d558f54c46531fb1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b7b5be8a42549d0e2e9400f63b7022"><td class="memItemLeft" align="right" valign="top">T const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtoefl_1_1_matrix.html#ae4b7b5be8a42549d0e2e9400f63b7022">getPtr</a> () const </td></tr>
<tr class="memdesc:ae4b7b5be8a42549d0e2e9400f63b7022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address of the first element for const reference.  <a href="#ae4b7b5be8a42549d0e2e9400f63b7022">More...</a><br /></td></tr>
<tr class="separator:ae4b7b5be8a42549d0e2e9400f63b7022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de80b0a0ce91964416b39c51ac46b67"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtoefl_1_1_matrix.html#a9de80b0a0ce91964416b39c51ac46b67">copy</a> () const </td></tr>
<tr class="memdesc:a9de80b0a0ce91964416b39c51ac46b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the data linearly and without padding to a std vector.  <a href="#a9de80b0a0ce91964416b39c51ac46b67">More...</a><br /></td></tr>
<tr class="separator:a9de80b0a0ce91964416b39c51ac46b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1050ba85376409c09b96a7d5b3ceba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtoefl_1_1_matrix.html#a5f1050ba85376409c09b96a7d5b3ceba">zero</a> ()</td></tr>
<tr class="memdesc:a5f1050ba85376409c09b96a7d5b3ceba"><td class="mdescLeft">&#160;</td><td class="mdescRight">uses operator= to set memory to 0  <a href="#a5f1050ba85376409c09b96a7d5b3ceba">More...</a><br /></td></tr>
<tr class="separator:a5f1050ba85376409c09b96a7d5b3ceba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6697ba4f337254d25cf73e29c886195"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtoefl_1_1_matrix.html#ab6697ba4f337254d25cf73e29c886195">isVoid</a> () const </td></tr>
<tr class="memdesc:ab6697ba4f337254d25cf73e29c886195"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks whether matrix is empty i.e. no memory is allocated  <a href="#ab6697ba4f337254d25cf73e29c886195">More...</a><br /></td></tr>
<tr class="separator:ab6697ba4f337254d25cf73e29c886195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f1cd766abd446985c51923b6b2c55b"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtoefl_1_1_matrix.html#a07f1cd766abd446985c51923b6b2c55b">operator!=</a> (const <a class="el" href="classtoefl_1_1_matrix.html">Matrix</a> &amp;rhs) const </td></tr>
<tr class="memdesc:a07f1cd766abd446985c51923b6b2c55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">two Matrices are considered equal if elements are equal  <a href="#a07f1cd766abd446985c51923b6b2c55b">More...</a><br /></td></tr>
<tr class="separator:a07f1cd766abd446985c51923b6b2c55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf562d7f0077790582e297f1e6e6d8f"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtoefl_1_1_matrix.html#a5cf562d7f0077790582e297f1e6e6d8f">operator==</a> (const <a class="el" href="classtoefl_1_1_matrix.html">Matrix</a> &amp;rhs) const </td></tr>
<tr class="memdesc:a5cf562d7f0077790582e297f1e6e6d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">two Matrices are considered equal if elements are equal  <a href="#a5cf562d7f0077790582e297f1e6e6d8f">More...</a><br /></td></tr>
<tr class="separator:a5cf562d7f0077790582e297f1e6e6d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca998f5fb19bba6870a774f67a35d6d"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtoefl_1_1_matrix.html#a4ca998f5fb19bba6870a774f67a35d6d">operator()</a> (const size_t i, const size_t j)</td></tr>
<tr class="memdesc:a4ca998f5fb19bba6870a774f67a35d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">access operator  <a href="#a4ca998f5fb19bba6870a774f67a35d6d">More...</a><br /></td></tr>
<tr class="separator:a4ca998f5fb19bba6870a774f67a35d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a1f2b61fdee9e29e1c007c655b4fb0"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtoefl_1_1_matrix.html#a86a1f2b61fdee9e29e1c007c655b4fb0">operator()</a> (const size_t i, const size_t j) const </td></tr>
<tr class="memdesc:a86a1f2b61fdee9e29e1c007c655b4fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">const access operator  <a href="#a86a1f2b61fdee9e29e1c007c655b4fb0">More...</a><br /></td></tr>
<tr class="separator:a86a1f2b61fdee9e29e1c007c655b4fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6d742b5adef98ee880851a78a866005e"><td class="memTemplParams" colspan="2">template&lt;class T1 , enum Padding P1, class T2 , enum Padding P2&gt; </td></tr>
<tr class="memitem:a6d742b5adef98ee880851a78a866005e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtoefl_1_1_matrix.html#a6d742b5adef98ee880851a78a866005e">swap_fields</a> (<a class="el" href="classtoefl_1_1_matrix.html">Matrix</a>&lt; T1, P1 &gt; &amp;lhs, <a class="el" href="classtoefl_1_1_matrix.html">Matrix</a>&lt; T2, P2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6d742b5adef98ee880851a78a866005e"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap memories of two equally sized matrices of arbitrary type  <a href="#a6d742b5adef98ee880851a78a866005e">More...</a><br /></td></tr>
<tr class="separator:a6d742b5adef98ee880851a78a866005e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5baf9d8f440c1f53ed075cd3628906"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtoefl_1_1_matrix.html#a2a5baf9d8f440c1f53ed075cd3628906">permute_fields</a> (<a class="el" href="classtoefl_1_1_matrix.html">Matrix</a> &amp;first, <a class="el" href="classtoefl_1_1_matrix.html">Matrix</a> &amp;second, <a class="el" href="classtoefl_1_1_matrix.html">Matrix</a> &amp;third)</td></tr>
<tr class="memdesc:a2a5baf9d8f440c1f53ed075cd3628906"><td class="mdescLeft">&#160;</td><td class="mdescRight">permute memory of matrices with the same type  <a href="#a2a5baf9d8f440c1f53ed075cd3628906">More...</a><br /></td></tr>
<tr class="separator:a2a5baf9d8f440c1f53ed075cd3628906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da52c7e2044d7f2418d088dfca00c93"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtoefl_1_1_matrix.html#a8da52c7e2044d7f2418d088dfca00c93">operator</a> (std::ostream &amp;os, const <a class="el" href="classtoefl_1_1_matrix.html">Matrix</a> &amp;mat)</td></tr>
<tr class="memdesc:a8da52c7e2044d7f2418d088dfca00c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">print a <a class="el" href="classtoefl_1_1_matrix.html" title="Matrix class of constant size that provides fftw compatible dynamically allocated 2D fields...">Matrix</a> to the given outstream  <a href="#a8da52c7e2044d7f2418d088dfca00c93">More...</a><br /></td></tr>
<tr class="separator:a8da52c7e2044d7f2418d088dfca00c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df66e6fa6bd88312fa17678a47ff98b"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtoefl_1_1_matrix.html#a8df66e6fa6bd88312fa17678a47ff98b">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classtoefl_1_1_matrix.html">Matrix</a> &amp;mat)</td></tr>
<tr class="memdesc:a8df66e6fa6bd88312fa17678a47ff98b"><td class="mdescLeft">&#160;</td><td class="mdescRight">read values into a <a class="el" href="classtoefl_1_1_matrix.html" title="Matrix class of constant size that provides fftw compatible dynamically allocated 2D fields...">Matrix</a> from given istream  <a href="#a8df66e6fa6bd88312fa17678a47ff98b">More...</a><br /></td></tr>
<tr class="separator:a8df66e6fa6bd88312fa17678a47ff98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, enum Padding P = TL_NONE&gt;<br />
class toefl::Matrix&lt; T, P &gt;</h3>

<p><a class="el" href="classtoefl_1_1_matrix.html" title="Matrix class of constant size that provides fftw compatible dynamically allocated 2D fields...">Matrix</a> class of constant size that provides fftw compatible dynamically allocated 2D fields. </p>
<p>The primary goal of the <a class="el" href="classtoefl_1_1_matrix.html" title="Matrix class of constant size that provides fftw compatible dynamically allocated 2D fields...">Matrix</a> class is to provide a way to have a dynamically continuously allocated 2d field for either real or complex values. Once allocated the size (i.e. the number of rows and columns) of a <a class="el" href="classtoefl_1_1_matrix.html" title="Matrix class of constant size that provides fftw compatible dynamically allocated 2D fields...">Matrix</a> cannot be changed any more. The following example code should be pretty obvious: </p><div class="fragment"><div class="line">Matrix&lt;double&gt; m(3, 3);</div><div class="line">m.zero();</div><div class="line">m( 4,2) = 3;</div><div class="line">std::cout &lt;&lt; m &lt;&lt; std::endl; </div></div><!-- fragment --><p>Once you want to fourier transform a real matrix inplace you will be confronted with two issues: The first thing is that the result is of complex type and you probably want to calculate with complex numbers. Therefore there should be a way for a matrix to somehow change its type from real to complex. This is solved here by the globally defined swap_fields routine that exchanges the pointers to memory of two Matrices, even if the types are different. So if you swap pointers between a real and a complex matrix you effectively made the complex matrix real and the real matrix complex. If the additional allocated memory is of concern to you, there is the allocate flag in the constructor that you can set to TL_VOID. Then no memory is allocated, the only way for such a matrix to get memory is by swap_ping_ it in from another matrix by the swap_fields routine. See the example code: </p><div class="fragment"><div class="line">Matrix&lt;double&gt; m(5, 10);</div><div class="line">Matrix&lt;complex&lt;double&gt;&gt; cm( 5,5, <a class="code" href="group__containers.html#ggad5f39f322bf8f232863d5b5eda04749ba83385206f613ebea4231dd24f821a126">TL_VOID</a>); <span class="comment">//complex numbers have twice the size</span></div><div class="line">m.zero()</div><div class="line">m(0,1) = 5;</div><div class="line"><a class="code" href="classtoefl_1_1_matrix.html#a6d742b5adef98ee880851a78a866005e">swap_fields</a>( m, cm); <span class="comment">//now cm has an imaginary value at cm(0,0);</span></div></div><!-- fragment --><p> The second issue is that for an inplace transform the input array needs to be padded regardless of whether you want to perform many 1d (linewise) transformations or one 2d transformation. Therefore there needs to be a way to allocate a padded 2d field. This padded field then behaves like an unpadded field in all situations except that it is fourier transformable. See the <a class="el" href="fft_8h.html" title="wrapper functions for easy fftw plan creation ">fft.h</a> file for further information on that topic.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>This class is designed for primitive or trivial datatypes ( the ones that are "memcpy - able" ). This is important because we want to swap pointers between different types if the total amount of allocated memory is the same. T may in no case have dynamic allocated memory itself. </td></tr>
    <tr><td class="paramname">P</td><td>One of the values of the Padding enum, TL_NONE(default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The fftw_complex type does not work as a template paramter. (Mainly due to the comparison and istream and outstream methods) However std::complex&lt;double&gt; should be byte compatible so you can use reinterpret_cast&lt;fftw_complex*&gt;() on the pointer you get with <a class="el" href="classtoefl_1_1_matrix.html#a1a2bcfc1183ab0d558f54c46531fb1a3" title="get the address of the first element ">getPtr()</a> to use fftw routines! </dd>
<dd>
No errors are thrown if the macro TL_DEBUG is not defined </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af8f935080301ca145915c3e2330134fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , enum Padding P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtoefl_1_1_matrix.html">toefl::Matrix</a>&lt; T, P &gt;::<a class="el" href="classtoefl_1_1_matrix.html">Matrix</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allocate</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an empty matrix. </p>
<p>Allocate continous memory on the heap</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>logical number of rows (cannot be changed as long as memory is allocated for that object) </td></tr>
    <tr><td class="paramname">cols</td><td>logical number of columns (cannot be changed as long as memory is allocated for that object) </td></tr>
    <tr><td class="paramname">allocate</td><td>determines whether memory should actually be allocated. Use TL_VOID if matrix should be empty! Then only the swap_fields function can make the matrix usable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The physical size of the actually allocated memory depends on the padding type. (In the case that memory is allocated) </dd></dl>

</div>
</div>
<a class="anchor" id="a66fedb25468e7877b0c55d59ce9c1e35"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, enum Padding P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtoefl_1_1_matrix.html">toefl::Matrix</a>&lt; T, P &gt;::<a class="el" href="classtoefl_1_1_matrix.html">Matrix</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and assign memory on the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>logical number of rows (cannot be changed as long as memory is allocated for that object) </td></tr>
    <tr><td class="paramname">cols</td><td>logical number of columns (cannot be changed as long as memory is allocated for that object) </td></tr>
    <tr><td class="paramname">value</td><td>Use operator= of type T to assign values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aed10cba858c6e424122ced79fab91087"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, enum Padding P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtoefl_1_1_matrix.html">toefl::Matrix</a>&lt; T, P &gt;::<a class="el" href="classtoefl_1_1_matrix.html">Matrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtoefl_1_1_matrix.html">Matrix</a>&lt; T, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deep copy of an existing <a class="el" href="classtoefl_1_1_matrix.html" title="Matrix class of constant size that provides fftw compatible dynamically allocated 2D fields...">Matrix</a> </p>
<p>Copy of 1e6 double takes less than 0.01s </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the source matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If src is void then so will be this. </dd></dl>

</div>
</div>
<a class="anchor" id="aa49de9ed627cd38701282b03ea52e3f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, enum Padding P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtoefl_1_1_matrix.html">toefl::Matrix</a>&lt; T, P &gt;::<a class="el" href="classtoefl_1_1_matrix.html">Matrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtoefl_1_1_matrix.html">Matrix</a>&lt; T, P &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>temporary_src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Experimental move constructor in the new standard. </p>
<p>Does the same thing as the normal copy constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">temporary_src</td><td>The temporary source matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a171550ab096ef57acfbd755c7bfe930f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, enum Padding P = TL_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtoefl_1_1_matrix.html">toefl::Matrix</a>&lt; T, P &gt;::allocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory for void matrices. </p>
<p>This function uses the current values of n and m to allocate the right amount of memory! </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">A</td><td><a class="el" href="classtoefl_1_1_message.html" title="class intended for the use in throw statements ">Message</a> when called on non-void Matrices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acaaf1b7e09ef4b7524d6b36829f6e699"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, enum Padding P = TL_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="classtoefl_1_1_matrix.html">toefl::Matrix</a>&lt; T, P &gt;::cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of columns </p>
<p>Return the number of columns the object manages (the one you specified in the constructor), even if no memory is allocated. This number doesn't change as long as memory is allocated for that object. </p><dl class="section return"><dt>Returns</dt><dd>number of columns </dd></dl>

</div>
</div>
<a class="anchor" id="a9de80b0a0ce91964416b39c51ac46b67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, enum Padding P = TL_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="classtoefl_1_1_matrix.html">toefl::Matrix</a>&lt; T, P &gt;::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the data linearly and without padding to a std vector. </p>
<dl class="section return"><dt>Returns</dt><dd>newly instantiated vector holding a copy of the matrix data </dd></dl>

</div>
</div>
<a class="anchor" id="a1a2bcfc1183ab0d558f54c46531fb1a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, enum Padding P = TL_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classtoefl_1_1_matrix.html">toefl::Matrix</a>&lt; T, P &gt;::getPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the address of the first element </p>
<p>Replaces the use of &amp;m(0,0) which is kind of clumsy! </p><dl class="section return"><dt>Returns</dt><dd>pointer to allocated memory </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>DO NOT DELETE THIS POINTER!! This class manages the memory it allocates by itself. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4b7b5be8a42549d0e2e9400f63b7022"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, enum Padding P = TL_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const* <a class="el" href="classtoefl_1_1_matrix.html">toefl::Matrix</a>&lt; T, P &gt;::getPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the address of the first element for const reference. </p>
<p>Replaces the use of &amp;m(0,0) which is kind of clumsy! </p><dl class="section return"><dt>Returns</dt><dd>read only pointer to allocated memory </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>DO NOT DELETE THIS POINTER!! This class manages the memory it allocates by itself. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6697ba4f337254d25cf73e29c886195"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, enum Padding P = TL_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtoefl_1_1_matrix.html">toefl::Matrix</a>&lt; T, P &gt;::isVoid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks whether matrix is empty i.e. no memory is allocated </p>
<dl class="section return"><dt>Returns</dt><dd>true if memory isn't allocated </dd></dl>

</div>
</div>
<a class="anchor" id="a07f1cd766abd446985c51923b6b2c55b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , enum Padding P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classtoefl_1_1_matrix.html">toefl::Matrix</a>&lt; T, P &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtoefl_1_1_matrix.html">Matrix</a>&lt; T, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>two Matrices are considered equal if elements are equal </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="classtoefl_1_1_matrix.html" title="Matrix class of constant size that provides fftw compatible dynamically allocated 2D fields...">Matrix</a> to be compared to this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if rhs does not equal this </dd></dl>

</div>
</div>
<a class="anchor" id="a4ca998f5fb19bba6870a774f67a35d6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , enum Padding P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classtoefl_1_1_matrix.html">toefl::Matrix</a>&lt; T, P &gt;::<a class="el" href="classtoefl_1_1_matrix.html#a8da52c7e2044d7f2418d088dfca00c93">operator</a>() </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access operator </p>
<p>Performs a range check if TL_DEBUG is defined </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>row index </td></tr>
    <tr><td class="paramname">j</td><td>column index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to value at that location </dd></dl>

</div>
</div>
<a class="anchor" id="a86a1f2b61fdee9e29e1c007c655b4fb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , enum Padding P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classtoefl_1_1_matrix.html">toefl::Matrix</a>&lt; T, P &gt;::<a class="el" href="classtoefl_1_1_matrix.html#a8da52c7e2044d7f2418d088dfca00c93">operator</a>() </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>const access operator </p>
<p>Performs a range check if TL_DEBUG is defined </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>row index </td></tr>
    <tr><td class="paramname">j</td><td>column index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const value at that location </dd></dl>

</div>
</div>
<a class="anchor" id="aa748bce65eba4b471e48e02e2e92072c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , enum Padding P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtoefl_1_1_matrix.html">Matrix</a>&lt; T, P &gt; &amp; <a class="el" href="classtoefl_1_1_matrix.html">toefl::Matrix</a>&lt; T, P &gt;::<a class="el" href="classtoefl_1_1_matrix.html#a8da52c7e2044d7f2418d088dfca00c93">operator</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtoefl_1_1_matrix.html">Matrix</a>&lt; T, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deep assignment. </p>
<p>Copy every (including padded) value of the source <a class="el" href="classtoefl_1_1_matrix.html" title="Matrix class of constant size that provides fftw compatible dynamically allocated 2D fields...">Matrix</a> to the existing (non void) <a class="el" href="classtoefl_1_1_matrix.html" title="Matrix class of constant size that provides fftw compatible dynamically allocated 2D fields...">Matrix</a> with equal numbers of rows and columns. Copy of 1e6 double takes less than 0.01s </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the right hand side </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">A</td><td><a class="el" href="classtoefl_1_1_message.html" title="class intended for the use in throw statements ">Message</a> if src is void or doesn't have the same size as this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0c008428626e77f0d82eacab047cfe0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , enum Padding P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtoefl_1_1_matrix.html">Matrix</a>&lt; T, P &gt; &amp; <a class="el" href="classtoefl_1_1_matrix.html">toefl::Matrix</a>&lt; T, P &gt;::<a class="el" href="classtoefl_1_1_matrix.html#a8da52c7e2044d7f2418d088dfca00c93">operator</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtoefl_1_1_matrix.html">Matrix</a>&lt; T, P &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>temporary_src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deep move assignment. </p>
<p>Effectively the same as deep assignment but modifies its source </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">temporary_src</td><td>The temporary source matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">A</td><td><a class="el" href="classtoefl_1_1_message.html" title="class intended for the use in throw statements ">Message</a> if src is void or doesn't have the same size as this </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5cf562d7f0077790582e297f1e6e6d8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, enum Padding P = TL_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classtoefl_1_1_matrix.html">toefl::Matrix</a>&lt; T, P &gt;::<a class="el" href="classtoefl_1_1_matrix.html#a8da52c7e2044d7f2418d088dfca00c93">operator</a>== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtoefl_1_1_matrix.html">Matrix</a>&lt; T, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>two Matrices are considered equal if elements are equal </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="classtoefl_1_1_matrix.html" title="Matrix class of constant size that provides fftw compatible dynamically allocated 2D fields...">Matrix</a> to be compared to this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if rhs equals this </dd></dl>

</div>
</div>
<a class="anchor" id="aa52708d41add23f7cc585e8c2ba0485e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, enum Padding P = TL_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="classtoefl_1_1_matrix.html">toefl::Matrix</a>&lt; T, P &gt;::rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of rows </p>
<p>Return the number of rows the object manages (the one you specified in the constructor) even if no memory (or more in the padded case) is allocated. This number doesn't change as long as memory is allocated for that object. </p><dl class="section return"><dt>Returns</dt><dd>number of columns </dd></dl>

</div>
</div>
<a class="anchor" id="a5f1050ba85376409c09b96a7d5b3ceba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , enum Padding P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtoefl_1_1_matrix.html">toefl::Matrix</a>&lt; T, P &gt;::zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>uses operator= to set memory to 0 </p>
<p>takes less than 0.01s for 1e6 elements </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a8da52c7e2044d7f2418d088dfca00c93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, enum Padding P = TL_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtoefl_1_1_matrix.html">Matrix</a>&lt; T, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>print a <a class="el" href="classtoefl_1_1_matrix.html" title="Matrix class of constant size that provides fftw compatible dynamically allocated 2D fields...">Matrix</a> to the given outstream </p>
<p><a class="el" href="classtoefl_1_1_matrix.html" title="Matrix class of constant size that provides fftw compatible dynamically allocated 2D fields...">Matrix</a> is printed linewise with a newline after each line. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the outstream </td></tr>
    <tr><td class="paramname">mat</td><td>the matrix to be printed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the outstream </dd></dl>

</div>
</div>
<a class="anchor" id="a8df66e6fa6bd88312fa17678a47ff98b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, enum Padding P = TL_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; <a class="el" href="classtoefl_1_1_matrix.html#a8da52c7e2044d7f2418d088dfca00c93">operator</a>&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtoefl_1_1_matrix.html">Matrix</a>&lt; T, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read values into a <a class="el" href="classtoefl_1_1_matrix.html" title="Matrix class of constant size that provides fftw compatible dynamically allocated 2D fields...">Matrix</a> from given istream </p>
<p>The values are filled linewise into the matrix. Values are seperated by whitespace charakters. (i.e. newline, blank, etc) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>the istream </td></tr>
    <tr><td class="paramname">mat</td><td>the <a class="el" href="classtoefl_1_1_matrix.html" title="Matrix class of constant size that provides fftw compatible dynamically allocated 2D fields...">Matrix</a> into which the values are written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the istream </dd></dl>

</div>
</div>
<a class="anchor" id="a2a5baf9d8f440c1f53ed075cd3628906"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, enum Padding P = TL_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void permute_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtoefl_1_1_matrix.html">Matrix</a>&lt; T, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtoefl_1_1_matrix.html">Matrix</a>&lt; T, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtoefl_1_1_matrix.html">Matrix</a>&lt; T, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>third</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>permute memory of matrices with the same type </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>contains third on output </td></tr>
    <tr><td class="paramname">second</td><td>contains first on output </td></tr>
    <tr><td class="paramname">third</td><td>contains second on output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d742b5adef98ee880851a78a866005e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, enum Padding P = TL_NONE&gt; </div>
<div class="memtemplate">
template&lt;class T1 , enum Padding P1, class T2 , enum Padding P2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtoefl_1_1_matrix.html">Matrix</a>&lt; T1, P1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtoefl_1_1_matrix.html">Matrix</a>&lt; T2, P2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>swap memories of two equally sized matrices of arbitrary type </p>
<p>Performs a range check if TL_DEBUG is defined. The sizes of the actually allocated memory, which depend on padding and the value type, have to be equal. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>changes memory with rhs </td></tr>
    <tr><td class="paramname">rhs</td><td>changes memory with lhs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/matthias/feltor/inc/toefl/<a class="el" href="matrix_8h_source.html">matrix.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetoefl.html">toefl</a></li><li class="navelem"><a class="el" href="classtoefl_1_1_matrix.html">Matrix</a></li>
    <li class="footer">Generated on Thu Mar 30 2017 16:12:19 for TOEFL by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
